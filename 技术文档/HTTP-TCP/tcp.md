TCP
-

TCP(Transmission Control Protocol传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议。

TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。

TCP三次握手
-
    
   ![](../public/tcp-three.png)
   1. 第一次握手：建立连接时， 客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认
   2. 第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1), 同时发送一个自己的SYN包(syn=k), 即SYN+ACK，此时服务进入SYN_RECV状态
   3. 第三次握手：客户端收到SYN+ACK包，向服务器发送确认包ACK(ack=k+1), 客户端和服务器进入ESTABLISHED状态

TCP四次挥手
-

![](../public/tcp-four.png)
   1. 客户端先发送FIN，进入FIN_WAIT1状态
   2. 服务端收到FIN, 发送ACK，进入CLOSE_WAIT状态，客户端收到ACK， 进入FIN_WAIT2状态
   3. 服务端发送FIN，进入LAST_ACK状态
   4. 客户端收到FIN，发送ACK， 进入TIME_WAIT状态(延迟一段时间后CLOSED)，服务端收到ACK，进入CLOSED状态

   **TIME_WAIT**
   
   TIME_WAIT是主动关闭链接时形成，等待2MSL(约四分钟)， 主要是为了方式最后一个ACK丢失。服务端要尽量减少主动关闭链接
   
   **CLOSE_WAIT**
   
   CLOSE_WAIT是被动关闭链接形成的。 根据TCP状态机， 服务端收到客户端发送的FIN， 按照TCP实现发送ACK， 因此进入CLOSE_WAIT状态。
   如果服务不执行close(), 就不能从CLOSE_WAIT迁移到LAST_ACK, 系统中会存在很多的CLOSE_WAIT状态连接。 此时系统可能忙于处理读写，
   而未将已收到FIN的连接，进行close。此时recv/read已经收到FIN的连接socket， 会返回0。

   **TCP为什么不是两次连接**
   
   如果A和B两个进程通信，两次连接会出现一种情况：A发送玩请求报文之后，由于网路阻塞等原因B延迟很久收到，此时A认为此为失效报文。 
   网路恢复后， B收到报文向A发起连接，完成两次握手。 B任务此时已经建立通信连接，会一直等到A发送的请求，而A任务失效不会处理，会造成
   B的资源浪费
   
   **为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态**
   
   因为要考虑到网路是不稳定的，无法保证最后客户端发送的ACK会被服务端收到，所以服务处于LAST_ACK状态下的SOCKET可能因为超时为收到ACK，
   而重现发送FIN， TIME_WAIT状态是用来保证重发可能丢失ACK
   
   **TCP如何保证可靠传输**
   1. 三次握手
   2. 将数据截断为TCP适合发送的数据块的长度。按字节编码，合理分片
   3. 超时重发。 当TCP发出一个段后，启动一个定时器，如果不能及时收到确认就重发
   4. 对于收到的请求，给出确认响应
   5. 校验包有错，丢弃报文段，不给出响应
   6. 对失序数据进行重新排序，然后再交给应用层
   7. 能够丢弃重复数据
   8. 流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，防止较快主机致使较慢主机的
      缓冲区益处
   9. 拥塞控制，当网路拥塞时候，减少数据的发送

流量控制
-

TCP利用滑动窗口实现流量控制， 控制发送方发送速率

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小， 从而影响发送方的发送速率

流量控制指点对点通信量的控制

拥塞控制
-

- 拥塞控制是防止过多的数据注入网络中，可以使网路的路由器或链路不过载。 拥塞控制是一个全局性的过程
- 拥塞处理包含四个算法： 慢开始， 拥塞避免， 快速重传， 快速恢复
![](../public/avoid_congest.png)

慢开始
-

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

拥塞避免
-

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1， 而不是加倍。这样拥塞窗口按线性规律缓慢增长
        
    当cwnd < ssthresh时， 使用慢开始算法
    当cwnd > ssthresh时, 改用阻塞避免算法
    当cwnd = ssthresh时， 慢开始与拥塞算法任意
    
无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网路出现拥塞（没有收到确认），就把慢开始门限设置为出现拥塞时的发送窗口的一半，然后
把拥塞窗口设置为1，执行慢开始算法。

快速重传
-

快速重传要求接收方在收到一个失序的报文段后就立即发出重复确认，而不是要等到自己发送数据时捎带确认。 快重传算法规定， 发送方只要一连收到三个
重复确认就应该立即重传对方尚未收到的报文段，而不必等待设置的重传计时器时间到期

快速恢复
-

快速恢复算法：
    
   1. 当发送方连续收到三个重复确认时， 就执行乘法减小算法，将ssthresh门限减半。但接下去并不执行慢开始算法
   2. 考虑到如果网路出现拥塞的情况，就不会收到好几个重复的确认， 所以发送方现在任务网路可能没有出现拥塞。 此时不执行慢开始据算法，而是将
      cwnd设置为ssthresh的大小， 这发送方会重传此数据包

tcp如何保证包的顺序
-

主机每次发送数据时，TCP就给每个数据包分配一个序列号，并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机未收到确认，
则再次重传该数据包

TCP粘包和拆包
-

TCP是个“流”协议，所谓流，就是没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，
所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，
这就是所谓的TCP粘包和拆包的问题。

解决方法
-

1. 解决思路是在封装自己的包协议： 包=包内容长度(4byte)+包内容
    * 对于粘包问题： 先读出包头即包体长度n，然后再读取长度为n的包内容， 这样数据包之间的边界就清楚了
    * 对于拆包问题： 先读出包头， 由于此次读取的缓存区长度小于n， 这是需要先缓存这部分内容， 等待下次read事件来时拼接起来形成完整的数据包
2. 在包尾部增加回车或者空格等特殊字符进行分割