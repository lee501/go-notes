HTTP超文本传输协议
-

  1. 允许传输任意类型的数据对象， 有content-type加以标记
  2. 无状态协议： 指协议对事务的处理没有记忆能力。 缺少状态意味着如果后续需要前面的信息，则它必须重传。
  
HTTP2.0相比1.0的改进
-
 1. 多路复用
       -     多路复用允许同时通过单一的HTTP/2连接发起多重的请求-响应消息
 2. 二进制分帧
       -     http/2为了改进传输性能、实现低延迟和高吞吐量， 在应用层(HTTP/2)和传输层(TCP or UDP)之间增减一个二进制分帧层， 在二进制
            分帧层中， HTTP/2会将所有传输的信息分割为更小的消息和帧(frame), 并采用二进制格式的编码
 3. 首部压缩
       -     HTTP/2为首部压缩设计了HPACK算法
 4. 服务端推送
       -     服务端推送是一种在客户端请求之前发送数据的机制。在HTTP/2中，服务器可以对客户端的一个请求发送多个响应。 如果客户端早已在缓存
             中有一个copy， HTTP/2允许客户端通过RESET_STREAM主动取消push。 另一个方案， 客户端使用一个简介的Cache Digest来告诉服务器，
             哪些东西已经在缓存， 因此服务器会知道哪些是客户端需要的。
             
通信传输流
-
   ![](../public/stream-communication.png)
   
       发送端在层与层之间传输数据时， 每经过一层必定会被打上该层所属的首部信息。
       而接收端在层与层传输数据时，每经过一层时会把对应的首部消去
       
       ARP时一种用以解析地址的协议， 根据通信方的IP地址就可以查出对应的MAC地址
       
HTTP是无状态协议
-
       引入Cookie技术， 可以管理状态
       
Keep-Alive模式
-
       使用普通模式时， 每个请求和应答客户端和服务器都要建立一个连接，完成后立即断开
       启用Keep-Alive 模式(持久连接、 连接重用)，使客户端到服务器的连接持续有效， 当对服务器后续请求时，Keep-Alive避免建立或重新建立连接
       
       http/1.0默认是关闭的，需要在http头加入"Connection: Keep-Alive"
       http/1.1默认开始的， 需要加入"Connection: close"才关闭
  ![](../public/keep-alive.png)
  - 当Http采用keepalive, 客户端向服务器发送请求之后，如何判断服务器的数据已经发送完成
    1. 使用消息首部字段Content-Length
    2. 使用消息首部字段Transfer-Encoding
        -      当客户端向服务器请求一个静态页面或者一张图片的时候，服务器可以清楚的知道内容大小，通过Content-Length告诉客户端接收多少数据
               但是当动态页面的时候，不可能预先知道大小，这时候就可以使用Transfer-Encoding: chunk模式来传输数据
               
               chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明长度为0的chunk标示结束。
               每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数，正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF)隔开
               在最后一个长度为0的Chunk中的内容是称为footer的内容
Http方法
-
    get:客户端向服务端发起请求，获得资源。请求获得URL处所在的资源
        GET 请求有长度限制（浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url）
        GET产生一个TCP数据包（对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据)）
    post:向服务端提交新的请求字段。请求URL的资源后添加新的数据
        POST产生两个TCP数据包（对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)）
    head:请求获取URL资源的响应报告，即获得URL资源的头部
    patch：请求局部修改URL所在资源的数据项
    put：请求修改URL所在资源的数据元素
    delete：请求删除url资源的数据
    
HTTP长连接
-
HTTP1.0需要在头部增加"Connection：keep-alive", HTTP1.1默认支持
- http1.0请求与服务端的交互过程
        
        客户端发送带有一个header: "Connection: keep-alive的请求"
        服务端收到后，判断是长连接， 在response的header中也增加"keep-alive", 同时不会关闭已经建立的tcp连接
        客户端收到response后，不关闭该连接，并再次发送请求

HTTPS和HTTP的区别
-
        http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
        http默认使用80端口，https默认使用443端口
        
SSL/TLS作用(安全套接层)
-

    认证用户和服务器，确保数据发送到正确的客户机和服务器；
    加密数据以防止数据中途被窃取；
    维护数据的完整性，确保数据在传输过程中不被改变。
 ![](../public/ssl.png)
 
 Cookies和Session区别
 -
    Cookies是一种能够让网站服务器把少量数据储存到客户端的硬盘或内存，或是从客户端的硬盘读取数据的一种技术。
    Cookies是当你浏览某网站时，由Web服务器置于你硬盘上的一个非常小的文本文件，
    它可以记录你的用户ID、密码、浏览过的网页、停留的时间等信息。 
    session: 当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。
    当会话过期或被放弃后，服务器将终止该会话。 
    cookie机制：采用的是在客户端保持状态的方案，
    而session机制采用的是在服务端保持状态的方案。
    同时我们看到由于服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助cookie机制来达到保存标识的目的。
    
    Session是服务器用来跟踪用户的一种手段，每个Session都有一个唯一标识：session ID。当服务器创建了Session时，
    给客户端发送的响应报文包含了Set-cookie字段，其中有一个名为sid的键值对，这个键值Session ID。客户端收到后就把Cookie保存浏览器，
    并且之后发送的请求报表都包含SessionID。
    HTTP就是通过Session和Cookie这两个发送一起合作来实现跟踪用户状态，Session用于服务端，Cookie用于客户端